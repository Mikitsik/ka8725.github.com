I"{<p>Say you have CSV with header as a first row. It contains column names. And you have to parse this CSV. I have always been seeing code which solve this problem but it’s not so convenient and reliable as I wanted. The solution was unreliable and unmaintainable because there were hard-coded indexes for the columns: 0, 1, 2, … and etc. I decided to figure out how to use provided column names instead of numeric indexes. So welcome on broad.</p>

<h1 id="simple-solution">Simple solution</h1>

<p>Let’s we have this CSV:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">Make</span><span class="p">;</span> <span class="no">Model</span><span class="p">;</span> <span class="no">Year</span>
<span class="no">Audi</span><span class="p">;</span> <span class="mi">80</span><span class="p">;</span> <span class="mi">1994</span>
<span class="no">Audi</span><span class="p">;</span> <span class="no">A6</span><span class="p">;</span> <span class="mi">2005</span>
<span class="no">BMW</span><span class="p">;</span> <span class="mi">740</span><span class="p">;</span> <span class="mi">2001</span></code></pre></figure>

<p>The simplest solution with disadvantages will look like this:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">CSV</span><span class="p">.</span><span class="nf">foreach</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="ss">:headers</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">:col_sep</span> <span class="o">=&gt;</span> <span class="s1">';'</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">row</span><span class="o">|</span>
  <span class="no">Car</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">:make</span> <span class="o">=&gt;</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="ss">:model</span> <span class="o">=&gt;</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="ss">:year</span> <span class="o">=&gt;</span> <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="k">end</span></code></pre></figure>

<p>Disadvantages of this solution are obvious: if columns’ order changes you will get wrong system behavior and fail.</p>

<h1 id="robust-solution">Robust solution</h1>

<p>See how is simple to write more reliable code which solves this problem:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">CSV</span><span class="p">.</span><span class="nf">foreach</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="ss">:headers</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">:col_sep</span> <span class="o">=&gt;</span> <span class="s1">';'</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">row</span><span class="o">|</span>
  <span class="no">Car</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">:make</span> <span class="o">=&gt;</span> <span class="n">row</span><span class="p">[</span><span class="s1">'Make'</span><span class="p">],</span> <span class="ss">:model</span> <span class="o">=&gt;</span> <span class="n">row</span><span class="p">[</span><span class="s1">'Model'</span><span class="p">],</span> <span class="ss">:year</span> <span class="o">=&gt;</span> <span class="n">row</span><span class="p">[</span><span class="s1">'Year'</span><span class="p">])</span>
<span class="k">end</span></code></pre></figure>

<p>Pay attention that you are not able to get values of row through original string representation in symbols (:Make, :Model or :Year) and even through underscored strings/symbols (‘make’ or :make). To achieve this you should make monkey patch which resolves this problem. I won’t provide it here - it’s up to you.</p>

<p>This solution is more reliable - it’s ready for columns’ order changes, it’s readable for humans, it’s not sensible for number of columns. But there is a still possible fail - if there is a mistake in header of CSV this solution will fail too. In this case I can give only one advice - to check header, read column names before parsing. <code class="highlighter-rouge">CSV.foreach</code> methods receive more parameters, you can find their <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/csv/rdoc/CSV.html">here</a>.</p>

<p>PS. Firstly I’ve reinvented bicycle which reads first row and creates hash of indexes for each column (underscored symbol of column name as a key and index number as a value), but <a href="http://github.com/avsej">@avsej</a> proposed me this solution. Despite the fact that I didn’t find the solution from examples or official docs I’ve learned on more lesson here - don’t invent bicycle. Thanks for <a href="http://github.com/avsej">@avsej</a>!</p>
:ET