I"“C<p>Using <code class="highlighter-rouge">FactoryGirl</code> may cause issues in tests when you have complicated relations in a database. If you don‚Äôt pay enough attention to integrity in your tests there is a probability to stuck with the inconsistent data. An idea of the blog post to show the problem and give a solution to avoid the situation in your work. Also the solution will prevent some Ruby developers from the issue.</p>

<h2 id="problem">Problem</h2>

<p>Imagine you have a <code class="highlighter-rouge">User</code> model and it is related to an <code class="highlighter-rouge">Account</code> with ‚Äúmany to many‚Äù relation. Both <code class="highlighter-rouge">User</code> and <code class="highlighter-rouge">Account</code> belong to a <code class="highlighter-rouge">Company</code> and it‚Äôs impossible to attach a <em>user</em> from a <em>company #1</em> to an <em>account</em> from <em>company #2</em>. In general this is the obvious business rule and usually developers don‚Äôt have a validation or a restriction for the rule in a persistence layer of an application. Mostly the rule is implemented in a business layer (this is a controller‚Äôs layer in <a href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a> frameworks).</p>

<p>This is the UML diagram of the tables:</p>

<p><img src="/images/account-users.jpeg" alt="Account and User relation" /></p>

<p>Using <code class="highlighter-rouge">Rails</code>‚Äô <code class="highlighter-rouge">ActiveRecord</code> we would specify the following classes and relations:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Company</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:users</span>
  <span class="n">has_many</span> <span class="ss">:accounts</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:account_users</span>
  <span class="n">has_many</span> <span class="ss">:accounts</span><span class="p">,</span> <span class="ss">through: :account_users</span>
  <span class="n">belongs_to</span> <span class="ss">:company</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Account</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:account_users</span>
  <span class="n">has_many</span> <span class="ss">:users</span><span class="p">,</span> <span class="ss">through: :account_users</span>
  <span class="n">belongs_to</span> <span class="ss">:company</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">AccountUser</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:user</span>
  <span class="n">belongs_to</span> <span class="ss">:account</span>
<span class="k">end</span></code></pre></figure>

<blockquote>
  <p>NOTE: We won‚Äôt discuss here why we don‚Äôt use the Rails‚Äô <code class="highlighter-rouge">has_many_and_belongs_to</code> association. The topic worse its <a href="http://stackoverflow.com/questions/2780798/has-and-belongs-to-many-vs-has-many-through">own discussion</a> and its up to you what to use. But the specified relations will allow to understand the problem.</p>
</blockquote>

<p>Then using <a href="https://github.com/thoughtbot/factory_girl">FactoryGirl</a> in the tests you will have the following obvious (at first glance) factories:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">FactoryGirl</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="n">factory</span> <span class="ss">:company</span> <span class="k">do</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">FactoryGirl</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="n">factory</span> <span class="ss">:user</span> <span class="k">do</span>
    <span class="n">company</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">FactoryGirl</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="n">factory</span> <span class="ss">:account</span> <span class="k">do</span>
    <span class="n">company</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">FactoryGirl</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="n">factory</span> <span class="ss">:account_user</span> <span class="k">do</span>
    <span class="n">account</span>
    <span class="n">user</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>Now we are on the last step to realize the problem. Let‚Äôs go to rails console in test environment and try to create an <em>account-user</em> model with the specified <code class="highlighter-rouge">FactoryGirl</code>‚Äôs factory:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="err">$</span> <span class="n">rails</span> <span class="n">c</span> <span class="nb">test</span>
<span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">001</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="n">account_user</span> <span class="o">=</span> <span class="no">FactoryGirl</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">:account_user</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;AccountUser id: 1, account_id: 1, user_id: 1&gt;</span>
<span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">002</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="n">account_user</span><span class="p">.</span><span class="nf">user</span><span class="p">.</span><span class="nf">company</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;Company id: 2&gt;</span>
<span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">003</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="n">account_user</span><span class="p">.</span><span class="nf">account</span><span class="p">.</span><span class="nf">company</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;Company id: 1&gt;</span></code></pre></figure>

<p>Look at the result of the second and third commands - they return <em>company #1</em> and <em>company #2</em> respectively and this is the issue. Remember that we have the business rule that the situation is not possible. In a layer above (may be in controllers, form objects, policy objects or elsewhere) we may have the validation and the application is ready to use in production or development mode. But when we run tests we have the inconsistency and this may cause a lot of problems in your tests starting from performance issues and ending with unexpected behavior, which is difficult to debug to identify the problem.</p>

<p>If you still don‚Äôt get the problem this is a clue which may show that you do things in a wrong way - in tests you can have the following stepped preparation of the environment:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">company</span> <span class="o">=</span> <span class="n">create</span><span class="p">(</span><span class="ss">:company</span><span class="p">)</span>
<span class="n">user</span> <span class="o">=</span> <span class="n">create</span><span class="p">(</span><span class="ss">:user</span><span class="p">,</span> <span class="ss">company: </span><span class="n">company</span><span class="p">)</span>
<span class="n">account</span> <span class="o">=</span> <span class="n">create</span><span class="p">(</span><span class="ss">:account</span><span class="p">,</span> <span class="ss">company: </span><span class="n">company</span><span class="p">)</span>
<span class="n">account_user</span> <span class="o">=</span> <span class="n">create</span><span class="p">(</span><span class="ss">:account_user</span><span class="p">,</span> <span class="ss">user: </span><span class="n">user</span><span class="p">,</span> <span class="ss">account: </span><span class="n">account</span><span class="p">)</span></code></pre></figure>

<p>And this combination gives us a valid relation <em>account user</em> finally. Note, to create the valid relation we have four lines of code instead of simple one: <code class="highlighter-rouge">create(:account_user)</code>. Imagine that you have a lot of such relations in a database and you should understand the nightmare.</p>

<h2 id="solution">Solution</h2>

<p>Hopefully <code class="highlighter-rouge">FactoryGirl</code> has <a href="https://github.com/thoughtbot/factory_girl/blob/master/GETTING_STARTED.md">much useful functionality</a> and one of them solves the problem very easily. This is the <code class="highlighter-rouge">ignore</code> method (from 29 April of 2014 it is <a href="https://github.com/thoughtbot/factory_girl/commit/9610b389572913da0b01de519f3437cdeb764a59#diff-d41d8cd98f00b204e9800998ecf8427e">renamed</a> to <code class="highlighter-rouge">transient</code> and as I understand the new release will make you to use the new name). The method allows us to define <em>virtual</em> attributes on a factory. After this we will be able to pass additional options constructing a model with the <code class="highlighter-rouge">create</code> (or <code class="highlighter-rouge">build</code>) method of <code class="highlighter-rouge">FactoryGirl</code>.</p>

<blockquote>
  <p>This is the simplified explanation a purpose of the method and it explains only my vision to the method. If you are not happy with the explanation or want to know more, please, read full documentation of this <a href="https://github.com/thoughtbot/factory_girl/blob/master/GETTING_STARTED.md#transient-attributes">here</a>.</p>
</blockquote>

<p>Secondly we have to know that <code class="highlighter-rouge">FactoryGirl</code> has <a href="https://github.com/thoughtbot/factory_girl/blob/master/GETTING_STARTED.md#lazy-attributes">lazy</a> (in other words dynamic) attributes syntax. Pass a block to an attribute when you declare a factory and it will be evaluated on constructing a model each time and set the result to the attribute. The next code snippet will show syntax of the idea and you will understand what‚Äôs just explained.</p>

<p>Here we are and this is the improved factory:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">FactoryGirl</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="n">factory</span> <span class="ss">:account_user</span> <span class="k">do</span>
    <span class="n">ignore</span> <span class="k">do</span>
      <span class="n">company</span> <span class="p">{</span> <span class="n">create</span><span class="p">(</span><span class="ss">:company</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">end</span>

    <span class="n">account</span> <span class="p">{</span> <span class="n">create</span><span class="p">(</span><span class="ss">:account</span><span class="p">,</span> <span class="ss">company: </span><span class="n">company</span><span class="p">)</span> <span class="p">}</span>
    <span class="n">user</span> <span class="p">{</span> <span class="n">create</span><span class="p">(</span><span class="ss">:user</span><span class="p">,</span> <span class="ss">company: </span><span class="n">company</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>Now test the factory:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="err">$</span> <span class="n">rails</span> <span class="n">c</span> <span class="nb">test</span>
<span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">001</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="n">account_user</span> <span class="o">=</span> <span class="no">FactoryGirl</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">:account_user</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;AccountUser id: 1, account_id: 1, user_id: 1&gt;</span>
<span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">002</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="n">account_user</span><span class="p">.</span><span class="nf">user</span><span class="p">.</span><span class="nf">company</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;Company id: 1&gt;</span>
<span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">003</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="n">account_user</span><span class="p">.</span><span class="nf">account</span><span class="p">.</span><span class="nf">company</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;Company id: 1&gt;</span></code></pre></figure>

<p>Bingo! We‚Äôve solved the issue with the few lines of code. Now our factories give us possibility to refactor the tests, they don‚Äôt create trash in the environment and the data is <strong>integral</strong>!</p>

<p>As a bonus we can even pass a custom <em>company</em> to the factory constructor and it will create for us a <em>user</em> in the company, an <em>account</em> in the company and the <em>account user</em> relation:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">001</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="n">company</span> <span class="o">=</span> <span class="no">FactoryGirl</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">:company</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;Company id: 1&gt;</span>
<span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">002</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="n">account_user</span> <span class="o">=</span> <span class="no">FactoryGirl</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">:account_user</span><span class="p">,</span> <span class="ss">company: </span><span class="n">company</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;AccountUser id: 1, account_id: 1, user_id: 1&gt;</span>
<span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">003</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="n">account_user</span><span class="p">.</span><span class="nf">user</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;User id: 1, company_id: 1&gt;</span>
<span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">004</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="n">account_user</span><span class="p">.</span><span class="nf">account</span></code></pre></figure>

<p>Awesome, isn‚Äôt it?</p>

<h2 id="conclusion">Conclusion</h2>

<p>I know that somebody will say that these are obvious things but I‚Äôm sure that many Rails developers still have such issues in their projects. That‚Äôs why I decided to write the article to warn them.</p>

<p><code class="highlighter-rouge">FactoryGirl</code> is powerful software which gives us cool features to use in web development using <code class="highlighter-rouge">Ruby</code> language. But you  should use it with a caution to identify issues, like you saw in this post and solve them in time. It will prevent you from a nightmare and, may be, will make you a happy Ruby developer. I don‚Äôt promise that you will be a happy Ruby developer after this, but at least your developing process should bring you more satisfaction.</p>

<p>Now you are armed with a tool which prevents you from the pitfalls which we have in our project. I wish you to not stuck into the issue.</p>
:ET