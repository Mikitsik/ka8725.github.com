I"?<p>For the first glance it seems rather easy problem to find method definition. You know class name for the object, open documentation for this class and read it. But in real life it’s no so simple as seems. In Ruby the method for object can be defined from many places: modules, inheritance, meta-programming, other language’s extensions and etc. Imagine that you have installed a lot of gems in your application and every gem potentially can define or redefine method on any object. How to find the method definition in this situation?</p>

<h2 id="source-location">Source location</h2>

<p>Getting location of method definition is rather simple. Assume you have class <code class="highlighter-rouge">A</code> defined in the <code class="highlighter-rouge">a.rb</code> like this:</p>

<blockquote>
  <p>a.rb</p>
</blockquote>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">A</span>
  <span class="k">def</span> <span class="nf">m</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>In Ruby each method is an object too and you can get it using method with called <code class="highlighter-rouge">#method</code>. It returns object of class <code class="highlighter-rouge">Method</code>:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">m</span> <span class="o">=</span> <span class="no">A</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">method</span><span class="p">(</span><span class="ss">:m</span><span class="p">)</span> <span class="c1">#=&gt; #&lt;Method: A#m&gt;</span></code></pre></figure>

<p>Object of class <code class="highlighter-rouge">Method</code> has ‘#source_location’ method which returns the file where the method defined and the line:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">m</span><span class="p">.</span><span class="nf">source_location</span> <span class="c1">#=&gt; =&gt; ["/Users/ka8725/sl/a.rb", 2]</span></code></pre></figure>

<p>Now we know where the method is defined, open this file and see how it’s implemented. The method doesn’t work for methods which are defined with other languages extensions:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="p">{}.</span><span class="nf">method</span><span class="p">(</span><span class="ss">:[]</span><span class="p">).</span><span class="nf">source_location</span> <span class="c1">#=&gt; nil</span></code></pre></figure>

<p>And pay attention that methods which are defined by meta-programming can lose their source location too:</p>

<blockquote>
  <p>b.rb</p>
</blockquote>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">B</span>
  <span class="nb">class_eval</span> <span class="o">&lt;&lt;-</span><span class="no">M</span><span class="sh">
    def m
    end
</span><span class="no">  M</span>
<span class="k">end</span>

<span class="no">B</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">method</span><span class="p">(</span><span class="ss">:m</span><span class="p">).</span><span class="nf">source_location</span> <span class="c1">#=&gt; ["(eval)", 1]</span></code></pre></figure>

<p>Avoid missing line this way:</p>

<blockquote>
  <p>b.rb</p>
</blockquote>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">B</span>
  <span class="nb">class_eval</span> <span class="o">&lt;&lt;-</span><span class="no">M</span><span class="p">,</span> <span class="kp">__FILE__</span><span class="p">,</span> <span class="kp">__LINE__</span><span class="sh">
    def m
    end
</span><span class="no">  M</span>
<span class="k">end</span>

<span class="no">B</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">method</span><span class="p">(</span><span class="ss">:m</span><span class="p">).</span><span class="nf">source_location</span> <span class="c1">#=&gt; ["/Users/ka8725/sl/activebilling/b.rb", 5]</span></code></pre></figure>

<p>Feel free to use <code class="highlighter-rouge">#define_method</code> - it doesn’t lose it’s source location. But if method appears on the object with <code class="highlighter-rouge">#method_missing</code> help it can’t know anything about it’s definition place.</p>

<h2 id="practical-application">Practical application</h2>

<p>Recently I had a problem in our Rails application. I defined <code class="highlighter-rouge">Resource</code> model <code class="highlighter-rouge">ResourcesController</code> and as usual it’s routes but there was surprise when I opened page which contained this helper: <code class="highlighter-rouge">link_to 'Resource', resource_path(@resource)</code>. This code caused exception <code class="highlighter-rouge">SystemStackError - stack level too deep</code>. Rather strange situation, isn’t it? Going through sources of Rails I didn’t find any collisions there but finally with <code class="highlighter-rouge">Method#source_location</code> help I found the source of this method definition (it’s <a href="https://github.com/josevalim/inherited_resources">inherited_resources</a> gem which we use) and as a result I <a href="https://github.com/josevalim/inherited_resources/pull/318">patched this gem</a>. I would say that patch is good but at least it looks logical.</p>

<h2 id="conclusion">Conclusion</h2>

<p>No doubt that <code class="highlighter-rouge">Method#source_location</code> method is very helpful. But sometimes it can be useless whatever. So the conclusion here is avoid using <code class="highlighter-rouge">#method_missing</code> (there are many reasons to avoid it and this is one of the all cases).</p>
:ET