I"Á#<p>Have you ever struggled with slow tests in your Rails application? Do you know why your tests were slow? Well, it may seem not obvious, but most of the time tests spend on interacting with a database. We don‚Äôt prove this fact here because it‚Äôs quite <a href="https://evilmartians.com/chronicles/testprof-a-good-doctor-for-slow-ruby-tests">known one</a>, but we discuss a possible solution that might be helpful in some circumstances.</p>

<h3 id="problem">Problem</h3>

<p>Given a Rails app uses RSpec for tests and some Factory (FactoryBot for example) to create models in tests. The tests where models created with factory are slow. We want to make them faster.</p>

<h3 id="solution">Solution</h3>

<p>There are some bits of advice on how to speed up tests and they are clearly defined in this <a href="https://evilmartians.com/chronicles/testprof-a-good-doctor-for-slow-ruby-tests">article</a>. They are very helpful and, I must admit, they work well. But what if we want to gain more speed from our tests for whatever reason? As it‚Äôs already said, tests are slow because of interaction with a database. So what can we do then? It‚Äôs quite obvious - stub the code calls DB and call it a day. The only problem is that our app talks to DB for two reasons: to save data and to read data. And these are completely different problems that each require a specific approach. In this article, we discuss only the ‚Äúread‚Äù situation. The ‚Äúwrite‚Äù situation is left for the reader thoughts.</p>

<p>We already know they are slow because of touching DB. But which code exactly causes the issue? Let‚Äôs think first why we need real models created when we test a decorator. You may argue, but as I see, most of the time we need persisting models there to satisfy some select from DB, that‚Äôs actually <strong>scopes</strong> or <strong>associations</strong> in the Rails models layer. So, why not to stub these things?</p>

<p>Ok, we figured out that we need to stub associations and scopes in a test for a decorator. But how to do this exactly? Suppose, there is a code somewhere in deep of our models that‚Äôs called by our decorator: we test <code class="highlighter-rouge">SubscriptionDecorator.new(subscription).active_users</code> that actually turns into call <code class="highlighter-rouge">subscription.users.active.verified</code> underneath. A stub like this <code class="highlighter-rouge">allow(subscription).to receive(users).and_return([User.new])</code> won‚Äôt work, because there are no defined <code class="highlighter-rouge">active</code> or <code class="highlighter-rouge">verified</code> methods on it. So, looks like we need to stub it wisely. And here is what I suggest. Let‚Äôs create a clone of <code class="highlighter-rouge">ActiveRecord::Relation</code> that copies an association behavior:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ActiveRecordRelationStub</span>
  <span class="nb">attr_reader</span> <span class="ss">:records</span>
  <span class="k">alias</span> <span class="nb">to_a</span> <span class="n">records</span>

  <span class="c1"># @param model_klass [ActiveRecord::Base] the stubbing association's class</span>
  <span class="c1"># @param records [Array] list of records the association holds</span>
  <span class="c1"># @param scopes [Array] list of stubbed scopes</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">model_klass</span><span class="p">,</span> <span class="n">records</span><span class="p">,</span> <span class="ss">scopes: </span><span class="p">[])</span>
    <span class="vi">@records</span> <span class="o">=</span> <span class="n">records</span>

    <span class="n">scopes</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">scope</span><span class="o">|</span>
      <span class="nb">fail</span> <span class="no">NotImplementedError</span><span class="p">,</span> <span class="n">scope</span> <span class="k">unless</span> <span class="n">model_klass</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span>
      <span class="n">define_singleton_method</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span> <span class="k">do</span>
        <span class="nb">self</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

</code></pre></div></div>

<p>Having this in place, we can stub our association and scope:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user1</span> <span class="o">=</span> <span class="n">build_stubbed</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span>
<span class="n">user2</span> <span class="o">=</span> <span class="n">build_stubbed</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span>
<span class="n">allow</span><span class="p">(</span><span class="n">subscription</span><span class="p">).</span><span class="nf">to</span> <span class="n">receive</span><span class="p">(</span><span class="ss">:users</span><span class="p">).</span><span class="nf">and_return</span><span class="p">(</span><span class="no">ActiveRecordRelationStub</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">User</span><span class="p">,</span> <span class="p">[</span><span class="n">user1</span><span class="p">,</span> <span class="n">user2</span><span class="p">],</span> <span class="ss">scopes: </span><span class="p">[</span><span class="ss">:active</span><span class="p">,</span> <span class="ss">:verified</span><span class="p">]))</span>
</code></pre></div></div>

<p>In order to demonstrate how it works, for the sake of simplicity let‚Äôs have our <code class="highlighter-rouge">SubscriptionDecorator</code> class defined in the following way:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SubscriptionDecorator</span>
  <span class="c1"># ... details are hidden here</span>
  <span class="k">def</span> <span class="nf">active_users</span>
    <span class="n">subscription</span><span class="p">.</span><span class="nf">users</span><span class="p">.</span><span class="nf">active</span><span class="p">.</span><span class="nf">verified</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>And now when the call <code class="highlighter-rouge">SubscriptionDecorator#active_users</code> in tests with <code class="highlighter-rouge">SubscriptionDecorator.new(subscription).active_users</code> returns the stubbed relation with the records provided exactly like real models would behave. But keep in mind, here we don‚Äôt care about internal details of how the scopes (<code class="highlighter-rouge">verified</code> or <code class="highlighter-rouge">active</code>) are defined, what filters they use and so on. The real behavior of the scopes should be tested in the models on which they are defined. In other words, on decorators layer we rely on the scopes implementation and assume they work correctly and tested well, so that we can safely stub them. Please note, to prevent the mistake with stubbing an association that‚Äôs not defined, it‚Äôs better to use <a href="https://relishapp.com/rspec/rspec-mocks/docs/verifying-doubles/partial-doubles">verifying partial doubles</a>. If use it properly, RSpec checks whether the stubbed method is really defined or not, and if it‚Äôs not an exception is raised. So you are informed about this typo or mistake and can fix it not waiting for an error happened in production because you relied on tests that were weak. I highly recommend you to turn this option on globally for your tests to be on the safe side.</p>

<h3 id="conclusion">Conclusion</h3>

<p>I used the technique described in this article once and it was pretty successful. I managed to make our tests much faster. And of course, this approach can be used not only in tests for decorators, but for view specs, controllers specs and in any place when you don‚Äôt really need to check whether DB works properly but rather want to check <strong>your</strong> code. But this is not the whole story. There should be also defined aggregate functions, some filter methods and so on. If this approach works for you as well, I offer to comment on what functionality lacks <a href="https://gist.github.com/ka8725/de9e6a87d83a0f58ad3e3ba20ebaf3ae">here</a>.</p>

<h3 id="ps">PS</h3>

<p>If you have some questions left after reading this article, like ‚ÄúWhy should I care about tests speed?‚Äù or ‚ÄúWhat other possible options exist?‚Äù please read <a href="https://evilmartians.com/chronicles/testprof-a-good-doctor-for-slow-ruby-tests">this article</a> and especially the docs for <a href="https://test-prof.evilmartians.io">TestProf</a>.</p>
:ET